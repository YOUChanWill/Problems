package 分治算法;

public class Solution {

    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    /**剑指 Offer 07. 重建二叉树

     输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

     假设输入的前序遍历和中序遍历的结果中都不含重复的数字。*/
    public TreeNode buildTree(int[] preorder, int[] inorder) {

    }



    /**剑指 Offer 16. 数值的整数次方

     实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。*/
    public double myPow(double x, int n) {

    }



    /**剑指 Offer 33. 二叉搜索树的后序遍历序列

     输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
     如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。*/
    public boolean verifyPostorder(int[] postorder) {

    }


    /**剑指 Offer 17. 打印从1到最大的n位数

     输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。*/
    public int[] printNumbers(int n) {

    }


    /**剑指 Offer 51. 数组中的逆序对

     在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。*/
    public int reversePairs(int[] nums) {

    }

}
